# Copy Constructors in C++  

A **copy constructor** is a special constructor in C++ that creates a new object as a **copy** of an existing object. It ensures that the new object receives the same values as the original.  

## **Why Use a Copy Constructor?**  

- Ensures proper copying of objects, especially those managing **dynamic memory**.  
- Prevents unintended issues like **shallow copying** (explained later).  
- Helps when passing objects **by value** to functions or returning them from functions.  

---

## **How to Define a Copy Constructor?**  

A copy constructor takes a **constant reference** to an existing object of the same class:  

```cpp
class ClassName {
public:
    ClassName(const ClassName& other) {
        // Copy initialization logic
    }
};
```

If no copy constructor is explicitly defined, **C++ automatically provides a default one**.  

---

## **Example 1: Basic Copy Constructor**  

```cpp
#include <iostream>
using namespace std;

class Car {
public:
    string brand;
    int year;

    // Constructor
    Car(string b, int y) {
        brand = b;
        year = y;
    }

    // Copy Constructor
    Car(const Car& other) {
        brand = other.brand;
        year = other.year;
        cout << "Copy constructor called\n";
    }

    void display() {
        cout << "Brand: " << brand << ", Year: " << year << endl;
    }
};

int main() {
    Car car1("Toyota", 2022);
    Car car2 = car1;  // Copy constructor is invoked

    car1.display();
    car2.display();
}
```

### **Output:**  
```
Copy constructor called  
Brand: Toyota, Year: 2022  
Brand: Toyota, Year: 2022  
```
---

## **Default Copy Constructor and Dynamic Memory Issues**  

Consider the following example:

```cpp
#include <iostream>
using namespace std;

class MyClass {
    int* ptr;

public:
    // Constructor
    MyClass(int val) {
        ptr = new int(val);
    }

    void display() {
        cout << "Value: " << *ptr << endl;
    }
};

int main() {
    MyClass A(10);
    MyClass B = A; // Default copy constructor is called

    A.display();
    B.display();
}
```

Since no copy constructor is defined, **C++ provides a default one**, which looks like this:  

```cpp
// Default Copy Constructor (Generated by Compiler)
MyClass(const MyClass& other) {
    ptr = other.ptr;
}
```

Can you identify what might go wrong with this code?

---

## **The Problem with Shallow Copying**

Let's take a deeper look at what happens when we copy objects of the `MyClass` class:

### **Step 1: Creating Object A**  

Memory layout when `A` is created:

```cpp
+===========+                   
|     A     |                           
+-----------+           +====+
| ptr = 0x1 |---------->| 10 |  0x1 
+===========+           +====+
```

### **Step 2: Copying A to B**  

Since the default copy constructor **only copies the pointer**, the value of `ptr` in A, is assigned to `ptr` in B, this in turn leads to B pointing to the same memory as A:

```cpp
+===========+                   
|     A     |                           
+-----------+           +====+
| ptr = 0x1 |---------->| 10 |  0x1 
+===========+           +====+
+===========+              ^
|     B     |              |
+-----------+              | 
| ptr = 0x1 | -------------+
+===========+

```

### **Whatâ€™s the Issue?**  

- If we modify `*ptr` using `A`, the changes will reflect in `B`, since the pointers in each, point to the **same memory location**.  
- When `A` and `B` are destroyed, **`delete ptr` will be called twice**, leading to a **double free error** or undefined behavior.  

This is known as **shallow copying**.  

---

## **Shallow Copy vs. Deep Copy**  

| **Type**         | **Description** |
|-----------------|----------------|
| **Shallow Copy** | Copies the value of member variables as they are. If the member is a pointer, only the pointer address is copied, leading to memory sharing. |
| **Deep Copy**    | Allocates new memory and copies the actual data instead of just copying the pointer. |


### **Fixing the Issue with a Deep Copy Constructor**  

A deep copy constructor **allocates new memory** and copies the value from the original object instead of copying the pointer.  

```cpp
class MyClass {
    int* ptr;

public:
    MyClass(int val) {
        ptr = new int(val);
    }

    // Deep Copy Constructor
    MyClass(const MyClass& other) {
        ptr = new int(*other.ptr); // Allocate new memory and copy value
    }

    void display() {
        cout << "Value: " << *ptr << endl;
    }

    ~MyClass() {
        delete ptr; // Free allocated memory
    }
};

int main() {
    MyClass A(10);
    MyClass B = A; // Deep copy constructor is called

    A.display();
    B.display();
}
```

### **Fixed Memory Representation**  

Now, each object has its own memory:

```cpp
+===========+                   
|     A     |                           
+-----------+           +====+
| ptr = 0x1 |---------->| 10 |  0x1 
+===========+           +====+

+===========+
|     B     |
+-----------+           +====+  
| ptr = 0x2 | --------->| 10 |  0x2
+===========+           +====+
```

Now, `A.ptr` and `B.ptr` point to **different memory locations**, preventing unintended modifications and memory issues.  

---

## **Key Takeaways**  

- **Default copy constructor** performs a **shallow copy**, meaning it copies member variables **as they are**.  
- If a class contains **pointers**, a shallow copy results in **shared memory** issues.  
- A **deep copy constructor** should be implemented when dealing with **dynamic memory allocation**.  
- The deep copy constructor **allocates new memory** and copies the actual data instead of copying the pointer.  

Next, check out [this_operator.md](this_operator.md) to learn about the `this` pointer in C++.
